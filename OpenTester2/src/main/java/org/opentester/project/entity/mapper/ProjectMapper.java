package org.opentester.project.entity.mapper;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import org.opentester.project.dto.KeyValueDto;
import org.opentester.project.dto.PassFailDto;
import org.opentester.project.dto.ProjectDto;
import org.opentester.project.entity.PassFail;
import org.opentester.project.entity.ProjectEntity;
import org.opentester.project.entity.ProjectUserEntity;
import org.opentester.project.entity.SubRoleEntity;
import org.springframework.scheduling.annotation.Scheduled;

import com.ibm.icu.util.Calendar;

public class ProjectMapper extends DtoMapper<ProjectEntity, ProjectDto>{

	@Override
	public ProjectDto toDto(ProjectEntity entity) {

		List<String> operator = new ArrayList<>();//entity.allOperators().stream().map(o -> KeyValueDto.builder().key(o.getId()).value(o.getUsername()).build()).collect(Collectors.toList());
		List<String> teams = new ArrayList<>();
		Map<String, Integer> teamsMap = new HashMap<>();
		Map<String, Integer> rolesMap = new HashMap<>();
		for (ProjectUserEntity user : entity.allOperators()) {
			 if (user != null) {
				 //operator.add( KeyValueDto.builder().key(user.getId()).value(user.toString()).build());
				 if (user.affiliation() != null && !user.affiliation().isBlank()) {
					 if (!teamsMap.containsKey(user.affiliation())) {
						 teamsMap.put(user.affiliation(), 0);
					 }
					 teamsMap.put(user.affiliation(), teamsMap.get(user.affiliation()) + 1);
					 for (SubRoleEntity subRole : user.getSubRoles()) {
						 if (!rolesMap.containsKey(subRole.getName())) {
							 rolesMap.put(subRole.getName(), 0);
						 }
						 rolesMap.put(subRole.getName(), rolesMap.get(subRole.getName()) + 1); 
					 }
					 
					 
				 }
			 }
		}
		teamsMap.forEach((k,v) -> teams.add(k + ": " + v + " People"));
		rolesMap.forEach((k,v) -> operator.add(k + ": " + v + " People"));
		
		ProjectDto dto = ProjectDto.builder()
				.id(entity.getId())				
				.name(entity.getProjectName())
				.projectType(entity.getType())
				.completeDueDate(entity.completeDueDate())
				.completeDate(entity.completeDate())
				.status(new ProgressStatusGenerator().generate(entity.completeDueDate(), entity.completeDate(), entity.passFail()))
				.humanResource(new HumanResourceGenerator().generate(entity.allOperators()))
				//.qualification(operator)
				.member(entity.allOperators().stream().filter(u -> Objects.nonNull(u)).map(u -> u.full()).collect(Collectors.toList()))
				.location(new ArrayList<String>(entity.allLocations()))
				.passFailProgress(entity.passFail())
//				.teams(new ArrayList<String>(teams))
//				.passed(passFail.getPassed())
//				.failed(passFail.getFailed())
//				.untouched(passFail.getUntouched())
				.build();
		return dto;
	}

	@Override
	public ProjectEntity toEntity(ProjectDto dto) {
		return ProjectEntity.builder()
		.id(dto.getId())
		.projectName(dto.getName())
		.type(dto.getProjectType())
		.build();
	}

}
